/* Copyright 2008-2016 INSA-Lyon, CoReNum, ENS-Lyon
 * 
 * This file is part of libcrn.
 * 
 * libcrn is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * libcrn is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with libcrn.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * file: CRNUnivariateGaussianPDF.cpp
 * 
 * \author Jean DUONG, Yann LEYDIER
 */

#include <limits>
#include <CRNException.h>
#include <CRNStatistics/CRNStatisticSample.h>
#include <CRNMath/CRNUnivariateGaussianPDF.h>
#include <CRNMath/CRNEquationSolver.h>
#include <CRNMath/CRNMath.h>
#include <CRNData/CRNDataFactory.h>
#include <CRNUtils/CRNXml.h>
#include <CRNi18n.h>

using namespace crn;

/*!
 * Constructor
 *
 * \param[in] 	mu		mean
 * \param[in] 	v		variance
 */
UnivariateGaussianPDF::UnivariateGaussianPDF(double m, double v):
	mean(m),
	variance(v),
	scaleFactor(1.0 / sqrt(2.0 * M_PI * v))
{
}

/*!
 * Destructor
 */
UnivariateGaussianPDF::~UnivariateGaussianPDF(){}

/*! 
 * Sets the mean of a given density function
 *
 * \param[in]	mu	the new mean
 */
void UnivariateGaussianPDF::SetMean(const double mu) noexcept
{
	mean = mu;
}

/*! 
 * Sets the variance of a given density function
 *
 * \throw	ExceptionDimension	negative variance
 *
 * \param[in]	v	the new variance
 */
void UnivariateGaussianPDF::SetVariance(const double v)
{
	if (v < 0)
	{
		throw ExceptionDomain(StringUTF8("UnivariateGaussianPDF::SetVariance(const double v): ") + 
				_("Negative variance."));
	}

	variance = v;
	updateAuxiliaryAttributes();
}

/*! 
 * Evaluates a pattern
 *
 * \param[in]	x	the pattern to evaluate
 *
 * \return	the probability
 */
double UnivariateGaussianPDF::ValueAt(const double x) const
{	
	double y = x - mean;
	
	return scaleFactor * exp(- (y * y) / (2.0 * variance));
}

/*!
 * Internal
 */
void UnivariateGaussianPDF::updateAuxiliaryAttributes()
{
	scaleFactor = 1.0 / sqrt(2.0 * M_PI * variance);
}

/*!
 * Estimates intersection point between with another PDF, using trinom solving
 *
 * \param[in]	pdf	the other PDF
 * 
 * \return	the intersection abscissa
 */
double UnivariateGaussianPDF::IntersectionAbscissa(const UnivariateGaussianPDF &pdf) const
{
	double mu1 = GetMean();
	double mu2 = pdf.GetMean();
	double sigma1 = GetDeviation();
	double sigma2 = pdf.GetDeviation();
	double mu1_2 = mu1 * mu1;
	double mu2_2 = mu2 * mu2;
	double sigma1_2 = sigma1 * sigma1;
	double sigma2_2 = sigma2 * sigma2;
	
	double a = sigma1_2 - sigma2_2;
	double b = 2 * (mu1 * sigma2_2 - mu2 * sigma1_2);
	double c = mu2_2 * sigma1_2 - mu1_2 * sigma2_2 - 2 * sigma1_2 * sigma2_2 * (log(sigma1) - log(sigma2));
	
	std::set<double> roots = crn::QuadraticEquation::RealRoots(a, b, c);
	
	if (roots.size() == 1)
	{
		return *roots.begin();
	}
	else if (roots.size() == 2)
	{
		double x = *roots.begin();
		
		if((x - mu1) * (mu2 - x) < 0.0)
		{
			x = *(++roots.begin());
		}
		
		return x;
	}
	
	return std::numeric_limits<double>::infinity();
}

/*!
 * Estimates intersection point between with another PDF, using dichotomy
 *
 * \param[in]	pdf	the other PDF
 * 
 * \return	the intersection abscissa
 */
double UnivariateGaussianPDF::IntersectionAbscissaApprox(const UnivariateGaussianPDF &pdf) const
{
	double mean = GetMean();
	double ext_mean = pdf.GetMean();
	
	if (mean != ext_mean)
	{
		double left_bound = Min(mean, ext_mean);
		double right_bound = Max(mean, ext_mean);
		double diff = ValueAt(left_bound) - pdf.ValueAt(left_bound);
		double unsigned_diff = fabs(diff);
		double ref_sgn = diff / unsigned_diff;
		
		while (right_bound - left_bound > std::numeric_limits<double>::epsilon())
		{
			double middle = (right_bound + left_bound) / 2;
			
			diff = ValueAt(middle) - pdf.ValueAt(middle);
			unsigned_diff = fabs(diff);
			
			if ((diff / unsigned_diff) == ref_sgn)
			{
				left_bound = middle;
			}
			else
			{
				right_bound = middle;
			}
		}
		
		return (right_bound + left_bound) / 2;
	}
	
	return std::numeric_limits<double>::infinity();
}

/*****************************************************************************/
/*! Simulate a random sample following the PDF's low
*
* \param[in]	n	size of sample
* \param[in]	m	temporary sample size
* \param[in]	reseed shall the random seed be reinitialized?
*
* \return a set of patterns generated by the mixture's low
*/
std::vector<double> UnivariateGaussianPDF::MakeRandomSample(size_t n, size_t m, bool reseed) const
{
	if (reseed)
	{
		srand((unsigned int)time(nullptr));
	}
	
	std::vector<double> sample;
	double sigma = sqrt(variance);
	
	for (size_t k = 0; k < n; k++)
	{		
		// cumulate a uniform sample with m numbers
		
		double s = 0.0;
		
		for (size_t i = 0; i < m; i++)
		{
			s += ((double)(rand())) / ((double)(RAND_MAX));
		}
		
		// Gaussian random number from uniform distribution
		
		s -= double(m) / 2.0;
		s *= sigma * sqrt(12.0 / double(m));
		s += mean;
		
		sample.push_back(s);
	}

	return sample;
}

/*!
 * Dumps a summary to a string
 * 
 * \return	the string
 */
String UnivariateGaussianPDF::ToString() const
{
	String s;
	s += U"Mean     = ";
	s += mean;
	s += U"\nVariance = ";
	s += variance;
	
	return s;
}

/*!
 * \throws	ExceptionInvalidArgument	not a UnivariateGaussianPDF
 * \throws	ExceptionNotFound	attribute not found
 * \throws	ExceptionDomain	wrong attribute
 * \param[in]	el	the element to read
 */
void UnivariateGaussianPDF::Deserialize(xml::Element &el)
{
	if (el.GetName() != "UnivariateGaussianPDF")
	{
		throw ExceptionInvalidArgument(StringUTF8("bool UnivariateGaussianPDF::Deserialize(xml::Element &el): ") +
				_("Wrong XML element."));
	}
	double m = el.GetAttribute<double>("mean", false); // may throw
	double v = el.GetAttribute<double>("variance", false); // may throw
	mean = m;
	variance = v;
}

xml::Element UnivariateGaussianPDF::Serialize(xml::Element &parent) const
{
	xml::Element el(parent.PushBackElement("UnivariateGaussianPDF"));
	
	el.SetAttribute("mean", mean);
	el.SetAttribute("variance", variance);
	
	return el;
}


CRN_BEGIN_CLASS_CONSTRUCTOR(UnivariateGaussianPDF)
	CRN_DATA_FACTORY_REGISTER(U"UnivariateGaussianPDF", UnivariateGaussianPDF)
	Cloner::Register<UnivariateGaussianPDF>();
CRN_END_CLASS_CONSTRUCTOR(UnivariateGaussianPDF)
